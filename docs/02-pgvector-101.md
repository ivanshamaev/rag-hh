# pgvector 101: векторный поиск в PostgreSQL

Руководство по расширению **pgvector**: как хранить эмбеддинги в PostgreSQL и как быстро искать по ним ближайшие записи (k-NN). Всё применимо к проекту RAG HH и к любому стеку с PostgreSQL.

---

## 1. Что такое pgvector

**pgvector** — это расширение (extension) для PostgreSQL, которое добавляет:

- Тип данных **`vector(n)`** — массив из `n` чисел с плавающей точкой (float4). Размерность `n` фиксирована для колонки.
- Операторы **расстояний** между векторами (L2, cosine, inner product и др.).
- Индексы для **приближённого поиска ближайших соседей** (IVFFlat, HNSW), чтобы не сканировать всю таблицу.

Плюсы для RAG и семантического поиска: один движок (PostgreSQL) для и метаданных документов, и векторов, и полнотекстового поиска при необходимости; ACID, бэкапы, репликация — как у обычной БД.

---

## 2. Установка и включение

В Docker мы используем образ `pgvector/pgvector:pg16`. Расширение включается один раз на уровне БД:

```sql
CREATE EXTENSION IF NOT EXISTS vector;
```

После этого тип `vector` и операторы доступны в этой БД. В проекте это делается в `db/init.sql` при первом запуске контейнера.

---

## 3. Тип vector(n)

- **Синтаксис**: `vector(384)` — вектор размерности 384.
- **Хранение**: каждый элемент — 4 байта (float4). Для 384 размерностей — около 1.5 KB на строку только на вектор.
- **Ввод в SQL**: строкой в формате `'[0.1, 0.2, -0.3, ...]'` или через параметр запроса (в коде передаём строку JSON-массива и делаем cast `%s::vector`).

Важно: размерность колонки должна совпадать с размерностью эмбеддингов модели. Смена модели с другой размерностью потребует `ALTER TABLE ... ALTER COLUMN embedding TYPE vector(N);` и пересчёта всех векторов.

---

## 4. Операторы расстояний

pgvector даёт несколько операторов. В RAG и семантическом поиске чаще всего используют **косинусное расстояние**.

| Оператор | Название | Описание |
|----------|----------|----------|
| `<->` | L2 (Euclidean) | Евклидово расстояние |
| `<#>` | Inner product | Минус скалярное произведение (для нормализованных векторов близко к косинусному расстоянию) |
| `<=>` | Cosine | Косинусное расстояние: `1 - cosine_similarity` |

**Косинусное расстояние** (`<=>`):

- Не зависит от длины вектора, только от направления. Для текстовых эмбеддингов это обычно то, что нужно.
- Значения от 0 (векторы совпадают по направлению) до 2 (противоположные). Чем меньше значение — тем «ближе».
- В проекте мы считаем **similarity** как `1 - (embedding <=> query_vector)`, чтобы получить число от 0 до 1 (больше — ближе).

Пример поиска топ-5 по косинусной близости:

```sql
SELECT id, name, 1 - (embedding <=> '[0.1, 0.2, ...]'::vector) AS similarity
FROM vacancies
ORDER BY embedding <=> '[0.1, 0.2, ...]'::vector
LIMIT 5;
```

Именно так устроен поиск в `app/vacancies.py` в `search_similar()`.

---

## 5. Точный поиск vs индекс

- **Без индекса**: PostgreSQL перебирает все строки, считает расстояние до каждого вектора и сортирует. Точный результат, но на больших таблицах медленно.
- **С индексом** (IVFFlat или HNSW): используется приближённый поиск — быстрее, но может пропустить часть соседей (ниже recall). Параметры индекса позволяют балансировать скорость и точность.

Для маленькой таблицы (сотни–несколько тысяч строк) можно работать **без индекса** — точный поиск будет быстрым. Для десятков тысяч и выше индексы становятся важны.

---

## 6. Индекс IVFFlat

**IVFFlat** (Inverted File with Flat storage) — индекс, который:

1. Делит векторы на `lists` кластеров (по умолчанию строится через k-means).
2. При поиске находит несколько наиболее подходящих кластеров и ищет только внутри них (плюс опционально соседние).

Параметр **`lists`**:

- Рекомендуют порядка `sqrt(число_строк)` или больше для качества; слишком большое значение — лишние накладные расходы.
- Для пустой или маленькой таблицы pgvector выдаёт NOTICE: *"ivfflat index created with little data. This will cause low recall."* — на старте проекта это нормально. После загрузки тысяч вакансий индекс можно пересоздать с большим `lists`.

Создание индекса для косинусного расстояния (как в проекте):

```sql
CREATE INDEX ON vacancies
USING ivfflat (embedding vector_cosine_ops)
WITH (lists = 100);
```

- **vector_cosine_ops** — класс операторов для косинусного расстояния (`<=>`). Для L2 используется `vector_l2_ops`, для inner product — `vector_ip_ops`.

Важно: IVFFlat — **приближённый** поиск. Для максимальной точности на маленьких данных индекс можно не создавать или временно удалить.

---

## 7. Индекс HNSW (кратко)

**HNSW** (Hierarchical Navigable Small World) — графовый индекс, часто даёт лучший recall при той же скорости, но строится дольше и потребляет больше памяти.

Пример (pgvector 0.5+):

```sql
CREATE INDEX ON vacancies
USING hnsw (embedding vector_cosine_ops)
WITH (m = 16, ef_construction = 64);
```

В проекте пока используется IVFFlat; при росте данных можно добавить HNSW и сравнить качество и скорость.

---

## 8. Best practices

1. **Размерность** — строго совпадает с моделью эмбеддингов. Одна колонка `vector(384)` на одну модель.
2. **Оператор** — для текстовых эмбеддингов обычно **cosine** (`<=>`, `vector_cosine_ops`). Не смешивать с L2 без веской причины.
3. **Индекс** — создавать после того, как в таблице уже есть достаточный объём данных (тысячи строк). При необходимости пересоздавать с увеличенным `lists` (IVFFlat) после значительного прироста данных.
4. **Параметр `lists`** — ориентир: не меньше `sqrt(N)`, для больших таблиц — больше для лучшего recall.
5. **Транзакции** — вставка/обновление векторов и обычные транзакции работают как в обычном PostgreSQL; индексы обновляются вместе с данными.

---

## 9. Где в проекте RAG HH

- Включение расширения и создание таблицы: `db/init.sql`.
- Таблица `vacancies`, колонка `embedding vector(384)`.
- Индекс IVFFlat: `vacancies_embedding_idx` в `db/init.sql`.
- Поиск: `search_similar()` в `app/vacancies.py` — `ORDER BY embedding <=> %s::vector LIMIT %s`.
- Запись вектора: `upsert_vacancy()` передаёт список float, в SQL он уходит как строка `'[...]'::vector` (см. `list_to_pgvector` в `app/db.py`).

Дальше: [RAG 101](03-rag-101.md) — как семантический поиск встраивается в полный RAG-пайплайн.
